# 8주차 자료 — 문자열 알고리즘 & 투포인터 / 슬라이딩 윈도우

> 주제  
> - 문자열 탐색 알고리즘 (KMP, Rabin-Karp)  
> - 문자열 처리 (단어 개수, 그룹 단어, 중복 검사 등)  
> - 투포인터(Two Pointers) / 슬라이딩 윈도우(Sliding Window) 기법  
> - 효율적인 부분 문자열 탐색 및 구간 합 문제 해결  
>
> 목표  
> - 문자열 탐색 알고리즘의 원리(KMP, 해시 기반 탐색) 이해  
> - 투포인터를 활용한 연속 부분합 / 구간 처리 효율화  
> - 문자열 문제에서 자료구조(딕셔너리, Counter)와 알고리즘의 적절한 결합 감각 익히기  

---

## 1. 알고리즘 유형 한눈에 보기

| 유형 | 핵심 아이디어 | 특징 / 주의점 |
|------|----------------|----------------|
| **KMP** | 접두사-접미사(Pi 배열) 활용해 불일치 시 점프 | 문자열 패턴 매칭 시 O(N+M) |
| **Rabin-Karp** | **롤링 해시(Rolling Hash)**를 이용한 해시값 비교로 빠른 문자열 탐색 | 해시 충돌 관리 및 모듈러 연산 주의 |
| **투포인터** | 두 인덱스로 구간을 조정하며 탐색 | 정렬된 배열에서 자주 사용 |
| **슬라이딩 윈도우** | 윈도우 범위를 한 칸씩 이동하며 계산 갱신 | 중복 계산 줄여 효율 상승 |

---

## 2. 필수 문제 (백준)

- **문자열 탐색 / 비교**:  
 [1786](https://www.acmicpc.net/problem/1786), [14425](https://www.acmicpc.net/problem/14425), [5525](https://www.acmicpc.net/problem/5525)  
- **문자열 처리 / 구현**:  
 [1157](https://www.acmicpc.net/problem/1157), [1316](https://www.acmicpc.net/problem/1316)  
- **투포인터 / 슬라이딩 윈도우**:  
 [2002](https://www.acmicpc.net/problem/2002), [2470](https://www.acmicpc.net/problem/2470), [1940](https://www.acmicpc.net/problem/1940), [2531](https://www.acmicpc.net/problem/2531)

---

## 3. 자주 발생하는 실수 체크리스트

- KMP에서 **Pi 배열** 계산 시 인덱스 오프셋 실수  
- Rabin-Karp에서 **해시 모듈러 연산 누락**으로 인한 오버플로  
- 투포인터에서 **start, end 포인터의 '누적/갱신' 범위** 및 이동 조건 실수  
- 슬라이딩 윈도우 갱신 시 **나가는 값('left' 포인터)의 상태 관리** 실수 (e.g., 딕셔너리/Set 업데이트)  
- 문자열 비교 시 **대소문자 구분** 실수  
- 입력 문자열 처리 시 `strip()` 누락  

---

## 4. 시간복잡도 요약

| 유형 | 알고리즘 / 연산 | 시간 복잡도 |
|------|----------------|--------------|
| KMP | 패턴 매칭 | O(N + M) |
| Rabin-Karp | 해시 비교 기반 매칭 | O(N + M) (평균), O(NM) (최악) |
| 투포인터 | 구간 탐색 | O(N) |
| 슬라이딩 윈도우 | 연속 부분합 / 문자 집합 유지 | O(N) |

---

## 5. 연습 루틴 (Day 1 ~ Day 5)

- **Day 1**: 문자열 탐색의 기본 원리 이해, 단순 탐색 구현 (1157, 1316)
- **Day 2**: KMP 알고리즘 Pi 배열 구현 (1786)
- **Day 3**: Rabin-Karp 알고리즘 원리 및 해시 구현 (14425, 5525)
- **Day 4**: 투포인터 기법 실습 (정렬, 부분합, 구간 탐색) (1940, 2470)
- **Day 5**: 슬라이딩 윈도우 실전 문제 (2002, 2531)

---

## 6. 미니 퀴즈

<details>
<summary>1. KMP 알고리즘이 효율적인 이유는?</summary>
KMP는 불일치가 발생했을 때, 이미 일치했던 접두사 정보를 활용해 비교를 되돌리지 않고 점프합니다. 이를 위해 **Pi 배열**(접두사와 접미사의 최대 일치 길이)을 이용해 O(N+M)의 시간 복잡도로 탐색이 가능합니다.
</details>
<br>

<details>
<summary>2. Rabin-Karp 알고리즘의 핵심 아이디어는?</summary>
문자열의 해시값을 이용해 빠르게 비교합니다. 매번 전체 문자열을 비교하는 대신, 윈도우 내 문자열의 해시를 갱신하며 패턴과 동일한 해시인지 확인합니다.
</details>
<br>

<details>
<summary>3. 투포인터와 슬라이딩 윈도우의 차이는?</summary>
투포인터는 구간의 양 끝을 자유롭게 조정하며 탐색하는 기법이고, 슬라이딩 윈도우는 일정 크기의 구간을 한 칸씩 이동하며 합이나 상태를 갱신하는 방식입니다.
</details>
<br>

<details>
<summary>4. 문자열 문제에서 Python의 내장 함수 대신 KMP를 써야 하는 이유는?</summary>
`in`, `find` 등의 내장함수는 구현체에 따라 O(NM)의 복잡도를 가질 수 있습니다. 반면, KMP는 항상 O(N+M)으로 안정적이고 효율적입니다.
</details>
<br>

<details>
<summary>5. 투포인터를 사용할 수 있는 전제 조건은?</summary>
대부분의 경우 **정렬된 배열**이어야 하며, 포인터 이동 방향이 **단조 증가/감소** 구조를 가져야 합니다.
</details>
<br>
