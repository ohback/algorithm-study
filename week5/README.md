# 5주차 자료 — 그리디 & 구현 / 완전탐색

> 주제  
> 
> -   그리디 알고리즘  
> -   브루트포스(완전탐색)  
> -   시뮬레이션  
>
> 목표  
> -   **그리디, 브루트포스, 시뮬레이션의 개념과 차이점**을 이해하고 문제 조건에 따라 적절한 접근 방식을 선택한다.  
> -   정렬, 누적합, 문자열/배열 조작 등 기본기를 활용한 문제 해결 능력을 강화한다.  
> -   백준 실습을 통해 탐욕적 선택, 전수 조사, 모의 실행 코드를 능숙하게 작성한다.  

---

## 1. 알고리즘 유형 한눈에 보기

| 유형 | 아이디어 | 장점 | 단점 |
| ---- | -------- | ---- | ---- |
| **그리디** | 매 단계에서 최적이라 생각되는 선택을 반복 | 빠르고 구현이 간단 | 항상 전역 최적 보장 안 됨 |
| **브루트포스** | 가능한 모든 경우를 전부 탐색 | 정답 보장 | 시간 복잡도 ↑, 입력 크기 제한적 |
| **시뮬레이션** | 문제 과정을 코드로 그대로 모사 | 직관적이고 범용적 | 코드 길어지고 실수 발생 가능 |

### 1-1. 알고리즘 상세 & 예제
#### A) 그리디 (Greedy)

- **아이디어**: 매 단계에서 현재 상황에서 가장 최적이라고 생각되는 선택을 반복해 최종 해답에 도달하는 방식입니다.
- **복잡도**: 대부분 **정렬 O(N log N) + 단순 순회 O(N)** 형태로 구현되며, 전체적으로는 O(N log N)이 지배적입니다.
- **성질**: 빠르고 구현이 간단하지만, 모든 문제에서 전역 최적해를 보장하지는 않습니다. 특정 조건(예: 동전 단위가 배수 관계)이 충족될 때만 최적해가 보장됩니다.
- **활용**: 거스름돈 문제, 회의실 배정 등 탐욕적인 선택이 최적의 결과를 이끌어내는 경우에 사용됩니다.

```Python
# 그리디 예시 (백준 11047번 '동전 0')
N, K = map(int, input().split())
coins = [int(input()) for _ in range(N)]

coins.sort(reverse=True)
count = 0
for coin in coins:
    count += K // coin
    K %= coin
    if K == 0:
        break
print(count)
```

#### B) 완전탐색 (Brute Force)

- **아이디어**: 가능한 모든 경우의 수를 하나도 빠짐없이 전부 시도하여 정답을 찾는 방식입니다.
- **복잡도**: 문제의 크기에 따라 **O(N²), O(N³)** 또는 **O(2^N)**과 같이 매우 높을 수 있으며, 입력 크기가 제한적일 때 주로 사용됩니다.
- **성질**: 모든 경우를 확인하므로 항상 정답을 보장합니다. 시간 복잡도가 높아 데이터의 양이 적을 때 효과적입니다.
- **활용**: 체스판 다시 칠하기, 분해합 등 모든 경우를 확인해도 시간 내에 해결할 수 있는 문제에 적용됩니다.

```Python
# 완전탐색 예시 (백준 1018번 '체스판 다시 칠하기')
N, M = map(int, input().split())
board = [input() for _ in range(N)]
min_changes = float('inf')

for r in range(N - 7):
    for c in range(M - 7):
        changes_W = 0
        changes_B = 0
        for i in range(8):
            for j in range(8):
                char = board[r + i][c + j]
                if (i + j) % 2 == 0:
                    if char != 'W': changes_W += 1
                    if char != 'B': changes_B += 1
                else:
                    if char != 'B': changes_W += 1
                    if char != 'W': changes_B += 1
        min_changes = min(min_changes, changes_W, changes_B)
print(min_changes)
```

#### C) 시뮬레이션 (Simulation)

- **아이디어**: 문제에서 제시한 규칙과 과정을 그대로 코드로 옮겨 결과를 도출하는 방식입니다.
- **복잡도**: 보드의 크기나 시뮬레이션 반복 횟수에 따라 달라지며, 주로 **O(NM)** 또는 **O(시뮬레이션 횟수 * 보드 크기)** 형태로 표현됩니다.
- **성질**: 특별한 알고리즘보다 **문제 해결 로직을 그대로 구현**하는 것이 중요하며, 코드가 길어지고 경계 조건 실수가 발생하기 쉽습니다.
- **활용**: 덩치, 사탕 게임처럼 복잡한 조건에 따라 상태가 변하는 문제를 해결하는 데 적합합니다.

```Python
# 시뮬레이션 예시 (백준 7568번 '덩치')
N = int(input())
people = [tuple(map(int, input().split())) for _ in range(N)]

ranks = []
for i in range(N):
    rank = 1
    for j in range(N):
        if i == j:
            continue
        if people[i][0] < people[j][0] and people[i][1] < people[j][1]:
            rank += 1
    ranks.append(rank)
print(*ranks)
```

## 2. 필수 문제 (백준)

### Greedy
- 11047 동전 0  
- 1931 회의실 배정  
- 1541 잃어버린 괄호  
- 13305 주유소  
- 11399 ATM  
- 2217 로프  
- 1026 보물  

### Brute Force
- 1018 체스판 다시 칠하기  
- 1436 영화감독 숌  
- 2231 분해합  

### 시뮬레이션
- 7568 덩치  
- 3085 사탕 게임  

---

## 3. 자주 발생하는 실수 체크리스트

- [ ] 그리디에서 “탐욕 선택”이 전역 최적을 보장하는지 증명 없이 사용  
- [ ] 브루트포스 탐색에서 반복 범위 누락 또는 인덱스 오류   
- [ ] 정렬 기준을 잘못 잡아 틀린 답 도출  
- [ ] 시간복잡도 고려 없이 불필요한 중첩 루프 사용  

---

## 4. 시간복잡도 요약

- **그리디**: 보통 정렬 O(N log N) + 단순 순회 O(N)  
- **브루트포스**: 문제 크기에 따라 O(N²) ~ O(2^N)  
- **시뮬레이션**: 보드 크기 기준 O(NM), 시뮬레이션 반복 횟수 × 보드 크기  

---

## 5. 연습 루틴

1. **기본 문제 풀이**  
   - 동전 0 (11047), ATM (11399), 보물 (1026)  
   - 체스판 다시 칠하기 (1018), 분해합 (2231)  

2. **응용 문제 풀이**  
   - 회의실 배정 (1931), 주유소 (13305), 로프 (2217)  
   - 덩치 (7568), 영화감독 숌 (1436)  

3. **심화 문제 풀이**  
   - 잃어버린 괄호 (1541), 사탕 게임 (3085)  

---

## 6. 미니 퀴즈

<details>
<summary>Q1. 동전 0 문제에서 “큰 단위 동전부터 쓰는 전략”이 항상 정답을 보장하는 이유는?</summary>
A1. 동전 단위가 배수 관계를 이루기 때문에, 큰 단위부터 greedy하게 선택해도 항상 최소 개수를 얻는다.
</details>

<details>
<summary>Q2. 회의실 배정 문제에서 회의 시작 시간을 기준으로 정렬하면 왜 최적해를 보장하지 못할까?</summary>
A2. 가장 빨리 끝나는 회의를 선택해야 최대 개수를 배치할 수 있기 때문이다. 시작 시간 기준은 중간에 긴 회의를 먼저 잡아 비효율적 결과가 나온다.
</details>

<details>
<summary>Q3. 체스판 다시 칠하기 문제에서 가능한 8×8 영역은 최대 몇 개인가? (N×M 보드)</summary>
A3. (N−7) × (M−7) 개.
</details>

<details>
<summary>Q4. 사탕 게임에서 교환 가능한 인접 위치는 총 몇 개인가?</summary>
A4. N×(N−1)개의 가로 쌍 + N×(N−1)개의 세로 쌍 = 2×N×(N−1).
</details>

<details>
<summary>Q5. 영화감독 숌 문제에서 “666”을 포함하는 수를 찾는 과정의 시간복잡도는?</summary>
A5. 문자열 포함 여부 체크 O(logN) × N개의 수를 확인하므로 대략 O(N log N).
</details>
